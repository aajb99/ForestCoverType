mean(lambda.save)
sd(lambda.save)
quantile(lambda.save, c(.025, .975))
#Given our data and prior knowledge, there is a
#95% probability that Catoo can identify between
#47% and 88% of individuals with colon cancer
# Rejection Sampling #
set.seed(1131)
# Proposed k value
k <- .25
#prior parameters
# shape <- 0.5
# rate <- 0.5
#collect data
data <- c(3, 3, 7, 1, 4, 6, 6, 7, 3, 1, 5, 5, 5, 3, 3, 0, 3, 1, 2, 2)
n <- length(data)
#Rejection sampling setup
iters <- 10000 #number of iterations
lambda.save <- NULL #initialize a variable to save the accepted values of the parameter
#function to evaluate the likelihood for different values of theta
likelihood <- function(lambda){dpois(data, lambda)}
#function to evaluate the prior distribution for different values of theta
prior <- function(lambda){
if(lambda >=0 & lambda<6){
5
}else{
if(lambda >= 6 & lambda < 26){
25
}else{
if(lambda >= 26 & lambda <= 126){
125
}else{
625
}
}
}
}
#check prior function
prior(5)
prior(25)
prior(125)
prior(625)
# g <- function(theta){
# 	0.5*dunif(theta)
# }
#
#
#
# theta.save <- NULL
# for(i in 1:100000){
# 	theta.dot <- runif(1)
# 	r <- likelihood(theta.dot)*prior(theta.dot)/g(theta.dot)
# 	accept <- sample(c(T, F), 1, prob=c(r, 1-r))
# 	if(accept==T){
# 		theta.save <- c(theta.save, theta.dot)
# 	}
# }
#
# #Check to make sure we saved enough theta values
# length(theta.save)
# #trace plot
# plot(theta.save, type='l')
#
# #Plot posterior distribution of theta
# plot(density(theta.save), main=expression(pi(theta~"| data")), xlab=expression(theta))
#
# #Note: Beta distribution is NOT the posterior this time, but if you'd like to compare this posterior to when we used the beta prior...
# curve(dbeta(x, y+0.5, n-y + 0.5), add=T, col='blue', lwd=2, lty=2)
#
# quantile(theta.save, prob=c(.025, .975))
# #Given our data and prior knowledge, there is a
# #95% probability that Catoo can identify between
# #48% and 87% of individuals with colon cancer
n
#prior parameters
shape <- 0.5
rate <- 0.5
#collect data
data <- c(3, 3, 7, 1, 4, 6, 6, 7, 3, 1, 5, 5, 5, 3, 3, 0, 3, 1, 2, 2)
n <- length(data)
#MCMC setup
iters <- 10000 #number of iterations
lambda.save <- rep(0, iters) #initialize a vector to save the accepted values of the parameter
lambda <- 0.5 #starting value of parameter
n.accept <- 0 #tracker: how many times do we accept the proposed value?
s <- 0.3 #standard deviation of the proposal distribution
#MCMC algorithm (metropolis random walk)
# MCMC
for(t in 1:iters){
#1. draw a proposal value of alpha from the proposal distribution
lambda.star <- rnorm(1, lambda, s)
if(lambda.star > 0){ #alpha has a lower limit of 0; thus, if alpha.star <= 0, then r=0 => automatically reject
#2. compute r (in this case, log(r)).
logr <- sum(dpois(data, lambda = lambda.star, log=T)) +
dgamma(lambda.star, shape = shape, rate = rate, log=T) -
sum(dpois(data, lambda = lambda, log=T)) -
dgamma(lambda, shape = shape, rate = rate, log=T)
#3. accept or reject alpha.star with prob. r
logu <- log(runif(1))
if(logu <= logr){ #if we randomly accept
lambda <- lambda.star
n.accept <- n.accept + 1
}
}#if alpha.star < 0, automatically reject
#4. Save the new value of alpha
lambda.save[t] <- lambda
}
lambda
# Look at a trace plot to assess convergence and determine burn-in
plot(lambda.save, type='l')
#how often did we accept?
n.accept/iters
#Plot the approximate posterior distribution
plot(density(lambda.save), main=expression(pi(lambda~"| data")), xlab=expression(lambda), lwd=2)
# Add line for the exact posterior distribution
lines(density(rgamma(10000, shape + sum(data), rate + n), adjust = 2), add=T, col='blue', lwd=2, lty=2)
#Can compute posterior summaries as usual with Monte Carlo sampling
mean(lambda.save)
sd(lambda.save)
quantile(lambda.save, c(.025, .975))
#Given our data and prior knowledge, there is a
#95% probability that Catoo can identify between
#47% and 88% of individuals with colon cancer
# Metropolis RW #
set.seed(1128)
#prior parameters
alpha <- 1
beta <- 4
#collect data
y <- 17
n <- 116
#MCMC setup
iters <- 10000 #number of iterations
theta.save <- rep(0, iters) #initialize a vector to save the accepted values of the parameter
theta <- 0.5 #starting value of parameter
n.accept <- 0 #tracker: how many times do we accept the proposed value?
s <- 0.3 #standard deviation of the proposal distribution
#MCMC algorithm (metropolis random walk)
for(i in 1:iters){
theta.dot <- rnorm(1, theta, s)
if(theta.dot <= 1 & theta.dot >=0){
logr <- dbinom(y, n, theta.dot, log=T) + dbeta(theta.dot, alpha, beta, log=T) - dbinom(y, n, theta, log=T) - dbeta(theta, alpha, beta, log=T)
logu <- log(runif(1))
if(logu <= logr){
theta <- theta.dot
n.accept <- n.accept+1
}
}
theta.save[i] <- theta
}
# Look at a trace plot to assess convergence and determine burn-in
par(mfrow=c(1,2))
plot(theta.save, type='l')
#how often did we accept?
n.accept/iters
burn <- 200
theta.use <- theta.save[-(1:burn)]
plot(theta.use, type='l')
#Plot the approximate posterior distribution
plot(density(theta.use), main=expression(pi(theta~"| data")), xlab=expression(theta), lwd=2)
# Add line for the exact posterior distribution
curve(dbeta(x, y+alpha, beta+n-y), add=T, col='blue', lwd=2, lty=2)
#Can compute posterior summaries as usual with Monte Carlo sampling
mean(theta.use)
sd(theta.use)
quantile(theta.use, c(.025, .975))
#Given our data and prior knowledge, there is a
#95% probability that Catoo can identify between
#47% and 88% of individuals with colon cancer
# Metropolis RW #
set.seed(1128)
#prior parameters
alpha <- 1
beta <- 4
#collect data
y <- 17
n <- 116
#MCMC setup
iters <- 10000 #number of iterations
theta.save <- rep(0, iters) #initialize a vector to save the accepted values of the parameter
theta <- 0.5 #starting value of parameter
n.accept <- 0 #tracker: how many times do we accept the proposed value?
s <- 0.3 #standard deviation of the proposal distribution
#MCMC algorithm (metropolis random walk)
for(i in 1:iters){
theta.dot <- rnorm(1, theta, s)
if(theta.dot <= 1 & theta.dot >=0){
logr <- dbinom(y, n, theta.dot, log=T) + dbeta(theta.dot, alpha, beta, log=T) - dbinom(y, n, theta, log=T) - dbeta(theta, alpha, beta, log=T)
logu <- log(runif(1))
if(logu <= logr){
theta <- theta.dot
n.accept <- n.accept+1
}
}
theta.save[i] <- theta
}
# Look at a trace plot to assess convergence and determine burn-in
par(mfrow=c(1,2))
plot(theta.save, type='l')
#how often did we accept?
n.accept/iters
burn <- 200
theta.use <- theta.save[-(1:burn)]
plot(theta.use, type='l')
#Plot the approximate posterior distribution
par(mfrow=c(1,2))
plot(density(theta.use), main=expression(pi(theta~"| data")), xlab=expression(theta), lwd=2)
# Add line for the exact posterior distribution
curve(dbeta(x, y+alpha, beta+n-y), add=T, col='blue', lwd=2, lty=2)
#Can compute posterior summaries as usual with Monte Carlo sampling
mean(theta.use)
sd(theta.use)
quantile(theta.use, c(.025, .975))
#Given our data and prior knowledge, there is a
#95% probability that Catoo can identify between
#47% and 88% of individuals with colon cancer
# Metropolis RW #
set.seed(1128)
#prior parameters
alpha <- 1
beta <- 4
#collect data
y <- 17
n <- 116
#MCMC setup
iters <- 10000 #number of iterations
theta.save <- rep(0, iters) #initialize a vector to save the accepted values of the parameter
theta <- 0.5 #starting value of parameter
n.accept <- 0 #tracker: how many times do we accept the proposed value?
s <- 0.3 #standard deviation of the proposal distribution
#MCMC algorithm (metropolis random walk)
for(i in 1:iters){
theta.dot <- rnorm(1, theta, s)
if(theta.dot <= 1 & theta.dot >=0){
logr <- dbinom(y, n, theta.dot, log=T) + dbeta(theta.dot, alpha, beta, log=T) - dbinom(y, n, theta, log=T) - dbeta(theta, alpha, beta, log=T)
logu <- log(runif(1))
if(logu <= logr){
theta <- theta.dot
n.accept <- n.accept+1
}
}
theta.save[i] <- theta
}
# Look at a trace plot to assess convergence and determine burn-in
par(mfrow=c(1,2))
plot(theta.save, type='l')
#how often did we accept?
n.accept/iters
burn <- 200
theta.use <- theta.save[-(1:burn)]
plot(theta.use, type='l')
#Plot the approximate posterior distribution
par(mfrow=c(1,1))
plot(density(theta.use), main=expression(pi(theta~"| data")), xlab=expression(theta), lwd=2)
# Add line for the exact posterior distribution
curve(dbeta(x, y+alpha, beta+n-y), add=T, col='blue', lwd=2, lty=2)
#Can compute posterior summaries as usual with Monte Carlo sampling
mean(theta.use)
sd(theta.use)
quantile(theta.use, c(.025, .975))
#Given our data and prior knowledge, there is a
#95% probability that Catoo can identify between
#47% and 88% of individuals with colon cancer
#prior parameters
shape <- 0.5
rate <- 0.5
#collect data
data <- c(3, 3, 7, 1, 4, 6, 6, 7, 3, 1, 5, 5, 5, 3, 3, 0, 3, 1, 2, 2)
n <- length(data)
#MCMC setup
iters <- 10000 #number of iterations
lambda.save <- rep(0, iters) #initialize a vector to save the accepted values of the parameter
lambda <- 0.5 #starting value of parameter
n.accept <- 0 #tracker: how many times do we accept the proposed value?
s <- 0.3 #standard deviation of the proposal distribution
#MCMC algorithm (metropolis random walk)
# MCMC
for(t in 1:iters){
#1. draw a proposal value of alpha from the proposal distribution
lambda.star <- rnorm(1, lambda, s)
if(lambda.star > 0){ #alpha has a lower limit of 0; thus, if alpha.star <= 0, then r=0 => automatically reject
#2. compute r (in this case, log(r)).
logr <- sum(dpois(data, lambda = lambda.star, log=T)) +
dgamma(lambda.star, shape = shape, rate = rate, log=T) -
sum(dpois(data, lambda = lambda, log=T)) -
dgamma(lambda, shape = shape, rate = rate, log=T)
#3. accept or reject alpha.star with prob. r
logu <- log(runif(1))
if(logu <= logr){ #if we randomly accept
lambda <- lambda.star
n.accept <- n.accept + 1
}
}#if alpha.star < 0, automatically reject
#4. Save the new value of alpha
lambda.save[t] <- lambda
}
lambda
# Look at a trace plot to assess convergence and determine burn-in
par(mfrow=c(1,2))
plot(lambda.save, type='l')
#how often did we accept?
n.accept/iters
burn <- 200
lambda.use <- lambda.save[-(1:burn)]
plot(lambda.use, type='l')
#Plot the approximate posterior distribution
par(mfrow=c(1,1))
plot(density(lambda.use), main=expression(pi(lambda~"| data")), xlab=expression(lambda), lwd=2)
# Add line for the exact posterior distribution
lines(density(rgamma(10000, shape + sum(data), rate + n), adjust = 2), add=T, col='blue', lwd=2, lty=2)
#Can compute posterior summaries as usual with Monte Carlo sampling
mean(lambda.use)
sd(lambda.use)
quantile(lambda.use, c(.025, .975))
#Given our data and prior knowledge, there is a
#95% probability that Catoo can identify between
#47% and 88% of individuals with colon cancer
#prior parameters
shape <- 0.5
rate <- 0.5
#collect data
data <- c(3, 3, 7, 1, 4, 6, 6, 7, 3, 1, 5, 5, 5, 3, 3, 0, 3, 1, 2, 2)
n <- length(data)
#MCMC setup
iters <- 10000 #number of iterations
lambda.save <- rep(0, iters) #initialize a vector to save the accepted values of the parameter
lambda <- 0.5 #starting value of parameter
n.accept <- 0 #tracker: how many times do we accept the proposed value?
s <- 0.3 #standard deviation of the proposal distribution
#MCMC algorithm (metropolis random walk)
# MCMC
for(t in 1:iters){
#1. draw a proposal value of alpha from the proposal distribution
lambda.star <- rnorm(1, lambda, s)
if(lambda.star > 0){ #alpha has a lower limit of 0; thus, if alpha.star <= 0, then r=0 => automatically reject
#2. compute r (in this case, log(r)).
logr <- sum(dpois(data, lambda = lambda.star, log=T)) +
dgamma(lambda.star, shape = shape, rate = rate, log=T) -
sum(dpois(data, lambda = lambda, log=T)) -
dgamma(lambda, shape = shape, rate = rate, log=T)
#3. accept or reject alpha.star with prob. r
logu <- log(runif(1))
if(logu <= logr){ #if we randomly accept
lambda <- lambda.star
n.accept <- n.accept + 1
}
}#if alpha.star < 0, automatically reject
#4. Save the new value of alpha
lambda.save[t] <- lambda
}
lambda
# Look at a trace plot to assess convergence and determine burn-in
par(mfrow=c(1,2))
plot(lambda.save, type='l')
#how often did we accept?
n.accept/iters
burn <- 50
lambda.use <- lambda.save[-(1:burn)]
plot(lambda.use, type='l')
#Plot the approximate posterior distribution
par(mfrow=c(1,1))
plot(density(lambda.use), main=expression(pi(lambda~"| data")), xlab=expression(lambda), lwd=2)
# Add line for the exact posterior distribution
lines(density(rgamma(10000, shape + sum(data), rate + n), adjust = 2), add=T, col='blue', lwd=2, lty=2)
#Can compute posterior summaries as usual with Monte Carlo sampling
mean(lambda.use)
sd(lambda.use)
quantile(lambda.use, c(.025, .975))
#Given our data and prior knowledge, there is a
#95% probability that Catoo can identify between
#47% and 88% of individuals with colon cancer
# Metropolis RW #
set.seed(1128)
#prior parameters
alpha <- 1
beta <- 4
#collect data
y <- 17
n <- 116
#MCMC setup
iters <- 10000 #number of iterations
theta.save <- rep(0, iters) #initialize a vector to save the accepted values of the parameter
theta <- 0.5 #starting value of parameter
n.accept <- 0 #tracker: how many times do we accept the proposed value?
s <- 0.3 #standard deviation of the proposal distribution
#MCMC algorithm (metropolis random walk)
for(i in 1:iters){
theta.dot <- rnorm(1, theta, s)
if(theta.dot <= 1 & theta.dot >=0){
logr <- dbinom(y, n, theta.dot, log=T) + dbeta(theta.dot, alpha, beta, log=T) - dbinom(y, n, theta, log=T) - dbeta(theta, alpha, beta, log=T)
logu <- log(runif(1))
if(logu <= logr){
theta <- theta.dot
n.accept <- n.accept+1
}
}
theta.save[i] <- theta
}
# Look at a trace plot to assess convergence and determine burn-in
par(mfrow=c(1,2))
plot(theta.save, type='l')
#how often did we accept?
n.accept/iters
burn <- 100
theta.use <- theta.save[-(1:burn)]
plot(theta.use, type='l')
#Plot the approximate posterior distribution
par(mfrow=c(1,1))
plot(density(theta.use), main=expression(pi(theta~"| data")), xlab=expression(theta), lwd=2)
# Add line for the exact posterior distribution
curve(dbeta(x, y+alpha, beta+n-y), add=T, col='blue', lwd=2, lty=2)
#Can compute posterior summaries as usual with Monte Carlo sampling
mean(theta.use)
sd(theta.use)
quantile(theta.use, c(.025, .975))
#Given our data and prior knowledge, there is a
#95% probability that Catoo can identify between
#47% and 88% of individuals with colon cancer
# Metropolis RW #
set.seed(1128)
#prior parameters
alpha <- 1
beta <- 4
#collect data
y <- 17
n <- 116
#MCMC setup
iters <- 10000 #number of iterations
theta.save <- rep(0, iters) #initialize a vector to save the accepted values of the parameter
theta <- 0.5 #starting value of parameter
n.accept <- 0 #tracker: how many times do we accept the proposed value?
s <- 0.3 #standard deviation of the proposal distribution
#MCMC algorithm (metropolis random walk)
for(i in 1:iters){
theta.dot <- rnorm(1, theta, s)
if(theta.dot <= 1 & theta.dot >=0){
logr <- dbinom(y, n, theta.dot, log=T) + dbeta(theta.dot, alpha, beta, log=T) - dbinom(y, n, theta, log=T) - dbeta(theta, alpha, beta, log=T)
logu <- log(runif(1))
if(logu <= logr){
theta <- theta.dot
n.accept <- n.accept+1
}
}
theta.save[i] <- theta
}
# Look at a trace plot to assess convergence and determine burn-in
par(mfrow=c(1,2))
plot(theta.save, type='l')
#how often did we accept?
n.accept/iters
burn <- 200
theta.use <- theta.save[-(1:burn)]
plot(theta.use, type='l')
#Plot the approximate posterior distribution
par(mfrow=c(1,1))
plot(density(theta.use), main=expression(pi(theta~"| data")), xlab=expression(theta), lwd=2)
# Add line for the exact posterior distribution
curve(dbeta(x, y+alpha, beta+n-y), add=T, col='blue', lwd=2, lty=2)
#Can compute posterior summaries as usual with Monte Carlo sampling
mean(theta.use)
sd(theta.use)
quantile(theta.use, c(.025, .975))
#Given our data and prior knowledge, there is a
#95% probability that Catoo can identify between
#47% and 88% of individuals with colon cancer
# Metropolis RW #
set.seed(1128)
#prior parameters
alpha <- 1
beta <- 4
#collect data
y <- 17
n <- 116
#MCMC setup
iters <- 10000 #number of iterations
theta.save <- rep(0, iters) #initialize a vector to save the accepted values of the parameter
theta <- 0.5 #starting value of parameter
n.accept <- 0 #tracker: how many times do we accept the proposed value?
s <- 0.3 #standard deviation of the proposal distribution
#MCMC algorithm (metropolis random walk)
for(i in 1:iters){
theta.dot <- rnorm(1, theta, s)
if(theta.dot <= 1 & theta.dot >=0){
logr <- dbinom(y, n, theta.dot, log=T) + dbeta(theta.dot, alpha, beta, log=T) - dbinom(y, n, theta, log=T) - dbeta(theta, alpha, beta, log=T)
logu <- log(runif(1))
if(logu <= logr){
theta <- theta.dot
n.accept <- n.accept+1
}
}
theta.save[i] <- theta
}
# Look at a trace plot to assess convergence and determine burn-in
par(mfrow=c(1,2))
plot(theta.save, type='l')
#how often did we accept?
n.accept/iters
burn <- 200
theta.use <- theta.save[-(1:burn)]
plot(theta.use, type='l')
#Plot the approximate posterior distribution
par(mfrow=c(1,1))
plot(density(theta.use), main=expression(pi(theta~"| data")), xlab=expression(theta), lwd=2)
# Add line for the exact posterior distribution
curve(dbeta(x, y+alpha, beta+n-y), add=T, col='blue', lwd=2, lty=2)
#Can compute posterior summaries as usual with Monte Carlo sampling
mean(theta.use)
sd(theta.use)
quantile(theta.use, c(.025, .975))
#Given our data and prior knowledge, there is a
#95% probability that Catoo can identify between
#47% and 88% of individuals with colon cancer
